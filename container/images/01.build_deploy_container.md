# 구독관리 서비스의 컨테이너 이미지 생성 및 배포 

구독관리 서비스, API Gateway인 Spring Cloud, Backing service인 MySQL, RabbitMQ, Eureka, Config서버를  
컨테이너 이미지로 만들고 배포하도록 하겠습니다.   

## 실습 순서  
| Group | Task              | Description               | Link   |
| :-----| :-----------------| :------------------------ | :------|
| 준비 | Jar파일명 정의 | 실행Jar파일명을 서비스명으로 정의 | [Link](#)  |
|      | SCG CORS정의 클래스 작성 | 멀티 도메인을 허용하기 위해 CORS정의 클래스 개발 | [Link](#)  |
|      | 구독관리 SecurityConfig의 CORS정의 수정 | 멀티 도메인을 허용하도록 수정 | [Link](#)  |
|      | 프론트엔드 apiInstance 수정 | SCG 호출 주소를 환경변수 이용하도록 수정 | [Link](#)  |
| 빌드 | 이미지 생성 manifest 작성 | React와 Java용 컨테이너 이미지 작성 Dockerfile 작성 | [Link](#)  |
|  | 실행Jar 생성 manifest 작성 | Docker Compose를 이용한 Jar생성을 위한 build.yml 작성 | [Link](#)  |
|  | 빌드/배포 manifest 작성 | 이미지 생성과 실행을 위한 docker-compose.yml 작성 | [Link](#)  |
|  | 실행 Jar 생성 | build.yml을 이용하여 실행 Jar 생성 | [Link](#)  |
| 배포 | 컨테이너로 실행 | docker-compose 명령을 이용하여 컨테이너로 실행 | [Link](#)  |
|  | 이미지 업로드 | 이미지 저장소에 생성된 이미지 업로드 | [Link](#)  |
|  | 테스트 | 전체 기능 테스트 | [Link](#)  |
| 저장 | Git 푸시 | 수정된 애플리케이션 소스에 원격 Git에 Push | [Link](#)  |

---

## 준비 > Jar파일명 정의
각 애플리케이션의 실행 Jar 파일명을 정의합니다.  

build.gradle에 아래예와 같이 정의를 추가합니다.  
```
bootJar {
    archiveFileName = "scg.jar"
}
```

아래는 대상 애플리케이션과 Jar파일명입니다.  
물론 jar파일명은 버전을 붙이거나 해서 다른 이름을 지정할 수도 있습니다.  
다만, 실습에서 사용하는 파일명으로 정의해 달라는 것이고 다른 이름으로 정의했다면 이후에 
배포/실행 manifest 파일인 docker-compose.yml 만들 때 정의한 이름을 사용하면 됩니다.     

| Group | Application       | Jar파일명 |
| :-----| :-----------------| :--------|
| Spring Cloud | config | config.jar |
|              | eureka | eureka.jar |
|              | SCG | scg.jar |
| 구독관리 | member-infra | member.jar |
|         | subrecommend-infra | subrecommend.jar |
|         | mysub-infra | mysub.jar |
|         | mygrp-infra | mygrp.jar |
|         | transfer | transfer.jar |

| [Top](#실습-순서) |

---

## 준비 > SCG CORS정의 클래스 작성
SCG에서 CORS(Cross Origin Resourcing Sharing)설정은 아래와 같이 application.yml에 있습니다.  
문제는 환경변수로 여러개의 멀티 도메인을 정의하기가 힘들다는 것입니다.  
물론 ALLOWED_ORIGINS1, ALLOWED_ORIGIN2와 같이 필요한만큼 환경변수를 만들어서 해도 됩니다.  

우리는 'ALLOWED_ORIGINS' 환경변수에 콤마로 원하는 도메인들을 정의하는 방식을 사용하고자 합니다.  

```
spring.cloud.gateway:
  # CORS
  globalcors:
    cors-configurations:
      '[/**]':
        allowedOrigins: "https://aaa.bbb.com"
        allowedMethods:
          - GET
      '[/api/**]':
        allowedOrigins:
          - http://localhost:3000
          - ${ALLOWED_ORIGINS:http://localhost:3000}
        allowedMethods:
          - GET
          - PUT
          - POST
          - DELETE
          - OPTIONS
        allowedHeaders: "*"
```

이를 위해서 CORS설정 클래스를 만듭니다.   

먼저 application.yml의 CORS 설정을 아래와 같이 변경합니다.  
```
spring.cloud.gateway:
  # CORS
  globalcors:
    allowedOrgins: ${ALLOWED_ORIGINS:http://localhost:3000}
```

그리고 build.gradle에 spring security 라이브러리를 추가합니다.  
```
dependencies {
    implementation 'org.springframework.cloud:spring-cloud-starter-gateway'
    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'

    //-- 기본 L/B인 Ribbon대신 Load Balancer사용
    implementation 'org.springframework.cloud:spring-cloud-starter-loadbalancer'
    //-- Load Balancer가 사용할 캐시를 Caffeine으로 변경
    implementation 'com.github.ben-manes.caffeine:caffeine'
    implementation 'org.springframework.boot:spring-boot-starter-cache'

    implementation 'io.jsonwebtoken:jjwt-api:0.12.5'
    implementation 'io.jsonwebtoken:jjwt-impl:0.12.5'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.12.5'

    implementation 'org.springframework.boot:spring-boot-starter-security'
}
```

com.subride.sc.scg 밑에 'config' 패키지를 생성합니다.  
그 밑에 SecurityConfig 클래스를 아래 내용으로 작성합니다.  
```
package com.subride.sc.scg.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebFluxSecurity
@SuppressWarnings("unused")
public class SecurityConfig {

    @Value("${spring.cloud.gateway.globalcors.allowedOrgins}")
    private String allowedOriginsStr;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(ServerHttpSecurity.CsrfSpec::disable);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        String[] allowedOrigins = allowedOriginsStr.split(",");

        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList(allowedOrigins));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
```

---

## 준비 > 구독관리 SecurityConfig의 CORS정의 수정
구독관리의 각 서비스의 SecurityConfig의 CORS정의를 수정하여 멀티 도메인을 허용하도록 합니다.  

member-infra의 common.config.SecurityConfig클래스를 오픈 합니다.  

위 쪽 프라퍼티 정의 밑에 아래 내용을 추가합니다.  
애플리케이션 설정의 AllowedOrigins값을 읽어 들이는 설정입니다.  
```
@Value("${AllowedOrigins}")
private String allowedOrigins;
```

이 설정은 Config 저장소의 common/application.yml에 정의되어 있습니다.  
common/application.properties에 현재는 http://localhost:3000번으로 정의되어 있습니다.   
컨테이너 실행 시 'FRONT_HOST' 환경변수에 원하는 멀티 도메인을 지정하여 동적으로 주입할 겁니다.  
```
{중략}
jwt:
{중략}

AllowedOrigins: ${FRONT_HOST}

# Logging
logging:
{중략}
```

CorsConfigurationSource메소드의 'configuration.setAllowedOrigins' 부분을 아래와 같이 변경 합니다.   
```
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList(allowedOrigins.split(",")));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
```

동일한 작업을 subrecommend-infra, mysub-infra, mygrp-infra, transfer 애플리케이션에서도 합니다.   

---

## 준비 > 프론트엔드 apiInstance 수정
프론트엔드의 src/utils/apiInstance 파일을 여십시오.  

현재는 무조건 SCG의 주소를 localhost:3000을 사용하도록 되어 있습니다.  
이를 환경변수에서 값을 읽도록 수정 합니다.  
```
const getBaseUrl = (serviceName) => {
  //SCG 통해 백엔드 접근  
  return "http://localhost:19080";
  
};
```

먼저 'container'브랜치를 만들고 이동합니다.   
```
git checkout -B container
```

아래와 같이 수정합니다.   
> **중요: 환경변수명은 반드시 'REACT_APP_'으로 시작**해야 함    
> React에서는 보안을 위해 process.env 명령을 이용하여 환경변수 접근을 제약하고 있습니다.  
> 약속된 방법으로 생성된 환경변수만 접근을 허용합니다.      
> webpack이라는 모듈을 이용, '.env'파일 이용, 이미지 빌드시 환경변수 주입의 3가지 방법으로 생성된   
> 환경변수만 접근을 허용합니다.    
> - webpack 이용 방식: 환경변수명에 제약이 없음   
>   ```
>   new webpack.DefinePlugin({
>     'process.env.API_BASE_URL': JSON.stringify('http://cna.subride.com:19080')
>   })
>   ```
> - '.env'파일 이용: Project의 Root에 '.env'라는 이름의 파일을 생성하고 그 안에 환경변수 정의   
>   환경변수명은 반드시 REACT_APP_ 으로 시작해야 함  
>   ```
>   REACT_APP_API_BASE_URL=http://cna.subride.com:3000
>   ```
> - 이ㅣ지 빌드시 환경변수로 주입. 환경변수명은 반드시 REACT_APP_ 으로 시작해야 함  
>   Dockerfile(이미지 생성 정의 manifest파일)에 ENV구문으로 정의  
>   ```
>   ENV REACT_APP_API_BASE_URL=http://cna.subride.com:3000
>   ```

우리는 3번째 방법을 사용합니다.  
별도 모듈이나 파일 생성 없이 이미지 생성때 주입만 하면 되기 때문에 가장 유연하고 편합니다.   
아래와 같이 함수를 수정하십시오.   
```
const getBaseUrl = (serviceName) => {
  return process.env.REACT_APP_API_BASE_URL || "http://localhost:19080";
};
```

---

## 빌드 > 이미지 생성 manifest 작성
컨테이너 이미지 생성 명세서 파일을 작성합니다.   
이 파일에서 base image, 환경변수, 필요 파일 복사, 실행 명령 등을 정의 합니다.  
파일명은 보통 'Dockerfile'로 하거나 'Dockerfile'로 시작합니다.   
컨테이너 기술을 발전시킨 Docker에서 처음 고안했기 때문인듯합니다.    
그래서 이 파일을 Dockerfile이라고 많이 부릅니다.   

먼저 빌드 관련 파일들을 모아놓을 디렉토리를 만듭니다.   
'홈/workspace' 디렉토리로 이동합니다.   
'buildfile'이라는 디렉토리를 만들고 이동합니다.   
```
cd ~/workspace  
mkdir buildfile && cd buildfile
```


- **Java용 Dockerfile 작성**   

    아래 내용으로 Java용 Dockerfile을 'Dockerfile_java'라는 이름으로 만듭니다.   
    ARTIFACTORY_FILE와 BUILD_LIB_DIR라는 파라미터를 받아서 이용합니다.   
    'docker build --build-arg ARTIFACTORY_FILE=member.jar'와 같은 형식으로 파라미터를 넘깁니다.  

    > **이미지 정의문 설명**  
    > - 파라미터 받기: 실행jar가 있는 폴더인 BUILD_LIB_DIR과 실행Jar파일명인 ARTIFACTORY_FILE을 받음   
    > - 실행user 생성: root로 실행하는 건 회사 보안 정책상 금지될 수 있으므로 실행 user를 생성  
    > - 작업디렉토리 정의: 컨테이너 안의 작업 디렉토리를 정의. 이 디렉토리가 컨테이너 안의 현재 폴더가 됨   
    > - 실행 jar 파일 복사: 실행 jar를 실행 user의 홈디렉토리로 복사   
    > - 애플리케이션 실행: 실행 user 권한으로 jar파일을 실행    
    >   ※ 만약 특정 profile로 실행하려면 PROFILE을 파라미터로 받아 주석 처리한 부분처럼 지정하면 됨  

    ```
    FROM openjdk:23-oraclelinux8

    ARG ARTIFACTORY_FILE
    ARG BUILD_LIB_DIR
    ENV ARTIFACTORY_FILE ${ARTIFACTORY_FILE}
    ENV BUILD_LIB_DIR ${BUILD_LIB_DIR}
    ENV USERNAME k8s
    ENV ARTIFACTORY_HOME /home/${USERNAME}

    # Add a user
    RUN adduser -r -G root -d ${ARTIFACTORY_HOME} -s /bin/bash ${USERNAME} && \
        echo "${USERNAME} ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers && \
        mkdir -p ${ARTIFACTORY_HOME} && \
        chown ${USERNAME}:root ${ARTIFACTORY_HOME}

    WORKDIR ${ARTIFACTORY_HOME}

    # Copy your jar to the container
    COPY ${BUILD_LIB_DIR}/${ARTIFACTORY_FILE} ${ARTIFACTORY_HOME}

    # Launch the artifactory
    ENTRYPOINT [ "sh", "-c" ]
    USER ${USERNAME}
    #CMD [ "java --Dspring.profiles.active=${PROFILE} -jar ${ARTIFACTORY_FILE}" ]
    CMD [ "java -jar ${ARTIFACTORY_FILE}" ]
    ```

- **React용 Dockerfile 작성**    
  
  아래 내용으로 React용 Dockerfile을 'Dockerfile_react_express'라는 이름으로 작성합니다.   

    ```
    # 베이스 이미지로 Node.js 14 버전을 사용합니다.
    FROM node:14

    # Arguments
    ARG PROJECT_FOLDER
    ARG BUILD_FOLDER
    ARG EXPORT_PORT

    # API G/W 호출 주소 환경변수 셋팅 
    ARG REACT_APP_API_BASE_URL
    ENV REACT_APP_API_BASE_URL=${REACT_APP_API_BASE_URL}

    # 작업 디렉토리를 /app으로 설정합니다.
    WORKDIR /app

    # package.json과 package-lock.json을 작업 디렉토리에 복사합니다.
    COPY ${PROJECT_FOLDER}/package*.json ./

    #copy server.js
    COPY ${BUILD_FOLDER}/server.js .

    # 종속성을 설치합니다.
    RUN npm install --only=production

    # 소스 코드를 작업 디렉토리에 복사합니다.
    COPY ./${PROJECT_FOLDER} .

    # React 애플리케이션을 빌드합니다.
    RUN npm run build

    # 서버 포트를 환경 변수로 설정합니다.
    ENV PORT=${EXPORT_PORT}

    # 포트를 노출합니다.
    EXPOSE $PORT

    # 서버 시작 스크립트를 실행합니다.
    CMD ["node", "server.js"]
    ```


