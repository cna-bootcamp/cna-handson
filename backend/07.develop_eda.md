# Event Driven Architecture 실습  
지금까지는 서비스간 동기 통신만 했습니다.  
이번에는 RabbitMQ을 메시지 브로커로 사용하여 비동기 통신을 구현해 보겠습니다.  

비동기 통신 대상은 '사용자가 가입한 구독서비스 목록을 리턴'하는 API입니다. 
![alt text](image.png)

아래 리턴값 예제와 같이 서비스에 대한 정보와 구독그룹 참여여부(joinGroup), 구독비용(payedFee),   
최대절감 가능액(discountedFee)을 리턴합니다.    
```
{
  "code": 200,
  "message": "구독 목록 조회 성공",
  "response": [
    {
      "userId": "user01",
      "subId": 37,
      "subName": "꾸까",
      "categoryName": null,
      "logo": "kukka.png",
      "description": "2주마다 꽃 배달 서비스",
      "fee": 30000,
      "maxShareNum": 3,
      "joinGroup": false,
      "payedFee": 30000,
      "discountedFee": 20000
    },
    {
      "userId": "user01",
      "subId": 20,
      "subName": "런드리고",
      "categoryName": null,
      "logo": "laundrygo.png",
      "description": "빨래구독 서비스",
      "fee": 35000,
      "maxShareNum": 2,
      "joinGroup": true,
      "payedFee": 35000,
      "discountedFee": 0
    },
    {
      "userId": "user01",
      "subId": 35,
      "subName": "미하이 삭스",
      "categoryName": null,
      "logo": "mehi.jpeg",
      "description": "매달 패션 양말 3종 배송",
      "fee": 990,
      "maxShareNum": 3,
      "joinGroup": false,
      "payedFee": 990,
      "discountedFee": 660
    }
  ]
}
```

이를 처리하기 위한 주요 메소드는 MySubProviderImpl의 getMySubList입니다.   
아래 코드에서 보다시피 Feign클라이언트를 이용하여 구도추천과 마이그룹서비스의 API를 호출하여  
그 결과로 조금 복잡한 연산을 하고 있습니다.  
```
@Override
public List<MySubInfoDTO> getMySubList(String userId) {
    List<MySubEntity> mySubEntityList = mySubRepository.findByUserId(userId);
    if (mySubEntityList.isEmpty()) {
        // userId에 해당하는 MySubEntity가 없는 경우 처리
        throw new InfraException(0, "해당 사용자의 구독 정보가 없습니다.");
    }

    List<Long> mySubIds = mySubEntityList.stream()
            .map(MySubEntity::getSubId)
            .collect(Collectors.toList());

    ResponseDTO<List<GroupSummaryDTO>> myGroupListResponse = myGroupFeignClient.getMyGroupList(userId);
    List<GroupSummaryDTO> myGroupList = myGroupListResponse.getResponse();

    ResponseDTO<List<SubInfoDTO>> response = subRecommendFeignClient.getSubInfoListByIds(mySubIds);
    List<SubInfoDTO> subInfoList = response.getResponse();

    return mySubEntityList.stream()
            .map(mySubEntity -> {
                MySubInfoDTO mySubInfoDTO = new MySubInfoDTO();
                mySubInfoDTO.setUserId(mySubEntity.getUserId());
                mySubInfoDTO.setSubId(mySubEntity.getSubId());

                //구독정보 찾기
                SubInfoDTO subInfo = subInfoList.stream()
                        .filter(dto -> dto.getSubId().equals(mySubEntity.getSubId()))
                        .findFirst()
                        .orElse(null);

                if(subInfo != null) {
                    mySubInfoDTO.setSubName(subInfo.getSubName());
                    mySubInfoDTO.setCategoryName(subInfo.getCategoryName());
                    mySubInfoDTO.setLogo(subInfo.getLogo());
                    mySubInfoDTO.setDescription(subInfo.getDescription());
                    mySubInfoDTO.setFee(subInfo.getFee());
                    mySubInfoDTO.setMaxShareNum(subInfo.getMaxShareNum());

                    // joinGroupMemberCountList에서 동일한 subId를 가진 객체 찾기
                    GroupSummaryDTO groupSummaryDTO = myGroupList.stream()
                            .filter(dto -> dto.getSubId().equals(mySubEntity.getSubId()))
                            .findFirst()
                            .orElse(null);

                    if (groupSummaryDTO != null) {
                        mySubInfoDTO.setJoinGroup(true);
                        mySubInfoDTO.setPayedFee(subInfo.getFee() / groupSummaryDTO.getMemberCount());
                        mySubInfoDTO.setDiscountedFee(0L);
                    } else {
                        mySubInfoDTO.setJoinGroup(false);
                        mySubInfoDTO.setPayedFee(subInfo.getFee());
                        mySubInfoDTO.setDiscountedFee(subInfo.getFee() - subInfo.getFee() / subInfo.getMaxShareNum());
                    }
                }
                return mySubInfoDTO;
            })
            .collect(Collectors.toList());
}
```

미리 필요한 정보를 마이구독 서비스가 갖고 있다면 이러한 통신과 복잡한 로직 처리가 필요 없을 겁니다.   
그래서 아래와 같이 비동기 통신을 통해 미리 필요한 정보를 마이구독 서비스가 갖고 있게 하겠습니다.  

![alt text](./images/image-eda1.png)   

위 Sequence diagram을 좀 더 단순화하면 아래와 같습니다.   
마이그룹 서비스는 그룹 생성, 참여, 탈퇴시 이벤트를 발행합니다.   
마이구독 서비스는 구독서비스 구독과 취소 시 이벤트를 발행합니다.  
이 이벤트들은 모두 마이구독 서비스가 구독하고 있고 RabbitMQ에서 이벤트 메시지를 받아 처리 합니다.   
![alt text](image-1.png)   

## 개발 순서  
| Group | Task              | Description               | Link   |
| :-----| :-----------------| :------------------------ | :------|
| 준비 | RabbitMQ 설치 | Docker로 RabbitMQ를 설치 | [Link](#)  |
|      | 애플리케이션 설정에 RabbitMQ 연결 설정 | Config저장소에 추가 | [Link](#)  |
| 개발 | Event 메시지 객체 개발 | Event 메시지를 설계하고 Event객체를 개발 | [Link](#)  |
|  | RabbitMQ 환경 설정 | 마이구독 서비스에 RabbitMQ 환경설정 클래스 추가하여 Queue생성 | [Link](#)  |

---

## 준비 > RabbitMQ 설치  
아래 명령으로 RabbitMQ를 설치 합니다.   
```
docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -e RABBITMQ_DEFAULT_USER=guest -e RABBITMQ_DEFAULT_PASS=guest rabbitmq:management-alpine 
```

실행이 된 후 웹브라우저에서 http://localhost:15672로 접근합니다.  
로그인은 ID와 암호 모두 guest를 입력하면 됩니다.  로그인 후 아래 화면이 나오면 잘 설치된겁니다.   
![alt text](image-2.png)  

---

## 준비 > 애플리케이션 설정에 RabbitMQ 연결 설정 
RabbitMQ와 인터페이스하는 서비스는 마이그룹과 마이구독 서비스입니다.   
두 서비스의 애플리케이션 설정에 RabbitMQ 연결 설정을 추가합니다.   
Git Config 저장소 수정을 위해 vscode에서 '홈/workspace/subride-config'디렉토리를 여십시오.   

mygrp-service/application.yml에 아래와 같이 rabbitmq 설정을 추가 합니다.  
```
spring:
  rabbitmq:
    host: ${RABBITMQ_HOST}
    port: ${RABBITMQ_PORT}
    username: ${RABBITMQ_USERNAME}
    password: ${RABBITMQ_PASSWORD}

```

mysub-service/application.yml에 아래와 같이 rabbitmq 설정을 추가 합니다.  
마이구독 서비스는 이벤트 메시지를 역직렬화(JSON문자열을 논리적 객체로 변환)해서 Event 객체를 만들어야 합니다.  
이를 위해 역직렬화를 허용할 객체를 지정해야 합니다.   
우리는 common프로젝트의 com.subride.common.event 패키지 하위에 이벤트 메시지를 위한 Event 객체를 만들겁니다.  
따라서 아래와 같이 지정하면 됩니다.   
```
spring:
  rabbitmq:
    host: ${RABBITMQ_HOST}
    port: ${RABBITMQ_PORT}
    username: ${RABBITMQ_USERNAME}
    password: ${RABBITMQ_PASSWORD}
    permitted-list-patterns:    #수신된 Event의 역직렬화를 허용할 객체 지정
      - com.subride.common.event.*
```

사용된 환경변수들의 값을 common/application.properties파일에 추가합니다.   
```
#RabbitMQ
RABBITMQ_HOST=localhost
RABBITMQ_PORT=5672
RABBITMQ_USERNAME=guest
RABBITMQ_PASSWORD=guest
```

---

## 개발 > Event 메시지 객체 개발
Event 메시지를 설계하고 Event 클래스를 추가합니다.   
이 Event 클래스는 이벤트 발행 서비스와 소비 서비스 모두 사용하므로 common 프로젝트에 만듭니다.  

먼저 마이그룹 서비스에서 발행하는 이벤트는 그룹생성, 그룹참여, 그룹탈퇴입니다.   
common프로젝트에 com.subride.common 밑에 event라는 패키지를 만듭니다.  
그 하위에 GroupEvent 클래스를 아래와 같이 작성합니다.  
> 주의: Event 클래스는 반드시 'implements Serializable'을 붙여야 함   

```
package com.subride.common.event;

import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;

/*
Event객체는 Serializable 인터페이스 반드시 필요
 */
@Getter
@Setter
public class GroupEvent implements Serializable {
    private String type;
    private String messageId;
    private String timestamp;
    private GroupEventPayload payload;

    @Getter
    @Setter
    public static class GroupEventPayload implements Serializable {
        private String userId;
        private Long groupId;
        private String groupName;
        private int memberCount;
        private Long subId;
    }
}
```

다음으로 마이구독 서비스는 서비스 구독과 구독 취소 이벤트를 발행합니다.   
com.subride.common.event 패키지 밑에 아래 내용으로 SubEvent 클래스를 만듭니다.  
```
package com.subride.common.event;

import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;

/*
Event객체는 Serializable 인터페이스 반드시 필요
 */
@Getter
@Setter
public class SubEvent implements Serializable {
    private String type;
    private String messageId;
    private String timestamp;
    private SubEventPayload payload;

    @Getter
    @Setter
    public static class SubEventPayload implements  Serializable {
        private String userId;
        private Long subId;
    }
}
```


---

## 개발 > RabbitMQ 환경 설정 
마이구독 서비스에 RabbitMQ 환경 설정 클래스를 작성합니다.   
이 클래스에서는 RabbitMQ 서버 연결, 이벤트 발행 객체, Queue를 생성합니다.   

그전에 RabbitMQ 라이브러리부터 마이구독서비스의 build.gradle에 추가 합니다.  
```
dependencies {
    implementation project(':common')
    implementation project(':mysub:mysub-biz')

    //-- OpenFeign Client: Blocking방식의 Http Client
    implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'

    //-- RabbitMQ
    implementation 'org.springframework.boot:spring-boot-starter-amqp'
}
```

com.subride.mysub.infra.common.config 패키지 밑에 RabbitMQConfig 클래스를 추가합니다.  
```
package com.subride.mysub.infra.common.config;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/*
RabbitMQ 컨테이너 배포
docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -e RABBITMQ_DEFAULT_USER=guest -e RABBITMQ_DEFAULT_PASS=guest rabbitmq:3.11-management
관리자 콘솔 접근: localhost:15672
*/
@Configuration
@SuppressWarnings("unused")
public class RabbitMQConfig {
    @Value("${spring.rabbitmq.host}")
    private String host;

    @Value("${spring.rabbitmq.username}")
    private String username;

    @Value("${spring.rabbitmq.password}")
    private String password;

    @Value("${spring.rabbitmq.port}")
    private int port;


    @Bean
    ConnectionFactory connectionFactory() {
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setHost(host);
        connectionFactory.setPort(port);
        connectionFactory.setUsername(username);
        connectionFactory.setPassword(password);
        return connectionFactory;
    }

    @Bean
    MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory, MessageConverter messageConverter) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(messageConverter);
        return rabbitTemplate;
    }

    //------------- 메시지 Exchange -----------
    @Bean
    public Exchange eventExchange() {
        return new TopicExchange("sub-event-exchange");
    }
    @Bean
    public DirectExchange subDlxExchange() {
        return new DirectExchange("sub-dlx-exchange");
    }
    //---------------------------------------

    //------------ 구독가입 이벤트 Queue --------------
    @Bean
    public Queue subscribeQueue() {
        return QueueBuilder.durable("subscribe-queue")
                .withArgument("x-dead-letter-exchange", "sub-dlx-exchange")
                .withArgument("x-dead-letter-routing-key", "subscribe-queue.dlx")
                .build();
    }

    @Bean
    public Queue subscribeDlxQueue() {
        return QueueBuilder.durable("subscribe-dlx-queue").build();
    }

    @Bean
    public Binding subscribeBinding(Queue subscribeQueue, TopicExchange eventExchange) {
        return BindingBuilder.bind(subscribeQueue).to(eventExchange).with("subscribe.#");
    }

    @Bean
    public Binding subscribeDlxBinding() {
        return BindingBuilder.bind(subscribeDlxQueue()).to(subDlxExchange()).with("subscribe-queue.dlx");
    }
    //----------------------------------------------

    //------------ 구독취소 이벤트 Queue -------------
    @Bean
    public Queue unsubscribeQueue() {
        return QueueBuilder.durable("unsubscribe-queue")
                .withArgument("x-dead-letter-exchange", "sub-dlx-exchange")
                .withArgument("x-dead-letter-routing-key", "unsubscribe-queue.dlx")
                .build();
    }

    @Bean
    public Queue unsubscribeDlxQueue() {
        return QueueBuilder.durable("unsubscribe-dlx-queue").build();
    }

    @Bean
    public Binding unsubscribeBinding(Queue unsubscribeQueue, TopicExchange eventExchange) {
        return BindingBuilder.bind(unsubscribeQueue).to(eventExchange).with("unsubscribe.#");
    }

    @Bean
    public Binding unsubscribeDlxBinding() {
        return BindingBuilder.bind(unsubscribeDlxQueue()).to(subDlxExchange()).with("unsubscribe-queue.dlx");
    }
    //----------------------------------------------

    //------------ 그룹 생성 이벤트 Queue ------------
    @Bean
    public Queue createGroupQueue() {
        return QueueBuilder.durable("create-group-queue")
                .withArgument("x-dead-letter-exchange", "sub-dlx-exchange")
                .withArgument("x-dead-letter-routing-key", "create-group-queue.dlx")
                .build();
    }

    @Bean
    public Queue createGroupDlxQueue() {
        return QueueBuilder.durable("create-group-dlx-queue").build();
    }

    @Bean
    public Binding createGroupBinding(Queue createGroupQueue, TopicExchange eventExchange) {
        return BindingBuilder.bind(createGroupQueue).to(eventExchange).with("create.group.#");
    }

    @Bean
    public Binding createGroupDlxBinding() {
        return BindingBuilder.bind(createGroupDlxQueue()).to(subDlxExchange()).with("create-group-queue.dlx");
    }
    //--------------------------------------------

    //------------- 그룹 참여 이벤트 Quee -----------0
    @Bean
    public Queue joinGroupQueue() {
        return QueueBuilder.durable("join-group-queue")
                .withArgument("x-dead-letter-exchange", "sub-dlx-exchange")
                .withArgument("x-dead-letter-routing-key", "join-group-queue.dlx")
                .build();
    }

    @Bean
    public Queue joinGroupDlxQueue() {
        return QueueBuilder.durable("join-group-dlx-queue").build();
    }

    @Bean
    public Binding joinGroupBinding(Queue joinGroupQueue, TopicExchange eventExchange) {
        return BindingBuilder.bind(joinGroupQueue).to(eventExchange).with("join.group.#");
    }

    @Bean
    public Binding joinGroupDlxBinding() {
        return BindingBuilder.bind(joinGroupDlxQueue()).to(subDlxExchange()).with("join-group-queue.dlx");
    }
    //-------------------------------------------

    //------------- 그룹 탈퇴 이벤트 Queue ----------
    @Bean
    public Queue leaveGroupQueue() {
        return QueueBuilder.durable("leave-group-queue")
                .withArgument("x-dead-letter-exchange", "sub-dlx-exchange")
                .withArgument("x-dead-letter-routing-key", "leave-group-queue.dlx")
                .build();
    }

    @Bean
    public Queue leaveGroupDlxQueue() {
        return QueueBuilder.durable("leave-group-dlx-queue").build();
    }

    @Bean
    public Binding leaveGroupBinding(Queue leaveGroupQueue, TopicExchange eventExchange) {
        return BindingBuilder.bind(leaveGroupQueue).to(eventExchange).with("leave.group.#");
    }

    @Bean
    public Binding leaveGroupDlxBinding() {
        return BindingBuilder.bind(leaveGroupDlxQueue()).to(subDlxExchange()).with("leave-group-queue.dlx");
    }
    //---------------------------------------------------

}
```

아래 부분이 RabbitMQ에 연결하고 RabbitMQ에 메시지를 발송하는 rabbitTemplate객체를 만드는 부분입니다.   
메시지 발송을 위해 직렬화(이벤트 객체를 JSON으로 변환)해야 하기 때문에 이를 위한 변환 메소드로 정의해야 합니다.   
> **참고: @Bean 어노테이션**   
> @Bean어노테이션을 붙인 메소드는 Spring IoC(Inversion Of Control) 컨테이너에 등록이 되어  
> 애플리케이션 실행 시 자동으로 객체가 생성됩니다.  
> 예를 들어 바로 아래 connectionFactory메소드가 Bean 메소드이기 때문에   
> 메소드명인 connectionFactory라는 객체가 애플리케이션 실행 시에 생성됩니다.  

```
@Bean
ConnectionFactory connectionFactory() {
    CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
    connectionFactory.setHost(host);
    connectionFactory.setPort(port);
    connectionFactory.setUsername(username);
    connectionFactory.setPassword(password);
    return connectionFactory;
}

@Bean
MessageConverter messageConverter() {
    return new Jackson2JsonMessageConverter();
}

@Bean
RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory, MessageConverter messageConverter) {
    RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
    rabbitTemplate.setMessageConverter(messageConverter);
    return rabbitTemplate;
}
```

RabbitMQ는 중계기(Exchanger)가 Queue를 할당하는 방식입니다.   
sub-event-exchange는 Event 메시지 안에 있는 Routing key의 prefix에 따라 Queue를 할당하는  
Topic Exchange 방식으로 분배 하도록 했습니다.   
저는 Routing key prefix에 이벤트 타입이 오도록 했습니다. 
예를 들어 'create.group.{메시지ID}'나 'join.group.{메시지ID}'와 같은 식입니다.   
이렇게 이벤트 타입에 따라 같은 타입의 이벤트는 같은 Queue에 할당함으로써 처리 순서 보장을 하였습니다. 
각 이벤트 타입별로 Queue가 하나이기 때문에 이렇게 하면 처리 순서 보장이 됩니다.  
만약 이벤트 타입별로 Queue를 여러개 만든다면 메시지ID를 Hashing하여 Queue를 할당해야 처리순서 보장이 됩니다.   

'sub-dlx-exchange' 중계기는 DLX(Dead Letter Exchange)는 문제가 발생한 이벤트 메시지를 별도의 DLX Queue로 보냅니다.   
이는 중복 처리 방지를 위해 사용합니다.   
RabbitMQ는 이벤트 처리 중 문제가 발생하면 Queue로 메시지를 반환 하고 주기적으로 다시 처리하도록 합니다.  
이때문에 중복 처리가 생길 수 있고, 계속 처리 실패 메시지가 콘솔을 가득 채우는 현상도 벌어집니다.   
그래서 DLX를 만들고 DLX Queue를 만들어 문제가 발생한 이벤트는 DLX Queue로 보내는 것이 필요합니다.   
DLX Queue의 메시지는 수동으로 처리하거나 다른 클래스에서 처리하는 로직을 만들어야 합니다.  
```

//------------- 메시지 Exchange -----------
@Bean
public Exchange eventExchange() {
    return new TopicExchange("sub-event-exchange");
}
@Bean
public DirectExchange subDlxExchange() {
    return new DirectExchange("sub-dlx-exchange");
}
//---------------------------------------

```

각 이벤트 타입별로 Queue와 DLX Queue만들고 중계기(Exchange)와 연결하는 부분입니다.   
```
//------------ 구독가입 이벤트 Queue --------------
@Bean
public Queue subscribeQueue() {
    return QueueBuilder.durable("subscribe-queue")
            .withArgument("x-dead-letter-exchange", "sub-dlx-exchange")
            .withArgument("x-dead-letter-routing-key", "subscribe-queue.dlx")
            .build();
}
@Bean
public Binding subscribeBinding(Queue subscribeQueue, TopicExchange eventExchange) {
    return BindingBuilder.bind(subscribeQueue).to(eventExchange).with("subscribe.#");
}

@Bean
public Queue subscribeDlxQueue() {
    return QueueBuilder.durable("subscribe-dlx-queue").build();
}
@Bean
public Binding subscribeDlxBinding() {
    return BindingBuilder.bind(subscribeDlxQueue()).to(subDlxExchange()).with("subscribe-queue.dlx");
}
//----------------------------------------------

```

---

## Git 푸시   

- Git Push 하기  
    IntelliJ에서 GitBash 터미널을 엽니다.   

    원격 Git repository에 푸시합니다.  
    ```
    git add . && git commit -m "sc" && git push -u origin sc
    ```

    v6.0.0으로 태깅하고 푸시합니다.  
    ```
    git tag -a v6.0.0 -m "Spring Cloud 연동" 
    git push origin v6.0.0
    ```

- 확인  
    github.com에서 잘 푸시되었는지 소스와 태그를 확인 합니다.  

| [Top](#spring-cloud-서버-연동) |

---

Spring Cloud Config, Eureka, SCG 서버와의 연동을 완료하였습니다.  
수고하셨습니다.   












